// // ブロックスコープについて学んだ。

// // 関数スコープとブロックスコープの違いは、  
// // 関数スコープは関数内でのみ有効な変数を定義できるのに対し、
// // ブロックスコープはブロック内でのみ有効な変数を定義できるという点。

// // ブロックスコープは、if文やfor文などのブロック内でのみ有効な変数を定義できる。

// // 普段使っていて、ブロックスコープを意識していないので、
// // ブロックスコープを意識してコードを書くのは難しいが参考になった

// // REPLでの動作。»はREPLの入力欄
// » {
//   const count = 1;
// }
// undefined // ここでブロック内で定義した変数`count`は参照できなくなる
// » {
//   const count = 1;
// }
// undefined // ここでブロック内で定義した変数`count`は参照できなくなる

// 関数宣言（文）と関数式
// 「関数と宣言」の章において、関数を定義する方法を学びました。 functionキーワードから文を開始する関数宣言と、変数へ関数式を代入する方法があります。

// 関数宣言（文）と関数式は、どちらもfunctionというキーワードを利用しています。

// // learn関数を宣言する関数宣言文
// function learn() {
// }
// // 関数式をread変数へ代入
// const read = function() {
// };
// この文と式の違いを見ると、関数宣言文にはセミコロンがなく、関数式にはセミコロンがあります。 このような違いがなぜ生まれるのかは、ここまでの内容から説明できます。

// 関数宣言（文）で定義したlearn関数には、セミコロンがありません。 これは、ブロックで終わる文にはセミコロンが不要であるためです。

// 一方、関数式をread変数へ代入したものには、セミコロンがあります。

// 「ブロックで終わる関数であるためセミコロンが不要なのでは？」と思うかもしれません。

// しかし、この無名関数は式であり、この処理は変数を宣言する文の一部であることがわかります。 つまり、次のように置き換えても同じと言えるため、末尾にセミコロンが必要となります。

// function fn() {}
// // fn(式)の評価値を代入する変数宣言の文
// const read = fn;

// //関数宣言文と関数式の違いは、関数宣言文はブロックで終わる文であるのに対し、関数式は式であるという点です。

//セミコロンの有無が何によるものなのかを理解することが大事。
//文の場合はセミコロンがないが、式の場合はセミコロンがある。

// まとめ
// この章では次のことについて学びました。

// JavaScriptは文（Statement）と式（Expression）から構成される
// 文は式になれない
// 式は文になれる（式文）
// 文の末尾にはセミコロンをつける
// ブロックで終わる文は例外的にセミコロンをつけなくてよい
// JavaScriptには、特殊なルールに基づき、セミコロンがない文も行末に自動でセミコロンが挿入されるという仕組みがあります。 しかし、この仕組みは構文を正しく解析できない場合に、セミコロンを足すという挙動を持っています。 これにより、意図しない挙動を生むことがあります。そのため、必ず文の末尾にはセミコロンを書くようにします。

// エディターやIDEの中にはセミコロンの入力の補助をしてくれるものや、ESLintなどのLintツールを使うことで、 セミコロンが必要なのかをチェックできます。

// セミコロンが必要か見分けるにはある程度慣れが必要ですが、ツールを使って静的にチェックできます。 そのため、ツールなどの支援を受けて経験的に慣れていくこともよい方法と言えます。